<!doctype html>
<html>
    <head></head>
    <body>
<script>
async function createImage(svgCode) {
    const url = URL.createObjectURL(
        new Blob([svgCode], { type: 'image/svg+xml' })
    );
    try {
        return await new Promise((r, rj) => {
            const im = new Image;
            im.onload = () => r(im);
            im.onerror = rj;
            im.src = url;
        });
    } finally {
        URL.revokeObjectURL(url);
    }
}

function getImageData(ctx, scale, image) {
    const width = Math.ceil(image.naturalWidth * scale);
    const height = Math.ceil(image.naturalHeight * scale);

    // Also resets the canvas
    ctx.canvas.width = width;
    ctx.canvas.height = height;

    ctx.drawImage(image, 0, 0, width, height);
    return ctx.getImageData(0, 0, width, height);
}

function imageDataEquals(a, b, maxChannelDiff) {
    if (a.width !== b.width) {
        return false;
    }
    if (a.height !== b.height) {
        return false;
    }
    for (let i = 0; i < a.data.length; i++) {
        const diff = a.data[i] - b.data[i];
        if (Math.abs(diff) > maxChannelDiff) {
            // console.log('Differs at offset', i, a, b);
            return false;
        }
    }
    return true;
}

const doNotRemoveAttrs = new Set(['xmlns', 'width', 'height', 'viewBox', 'd']);
const keepIfNonEmpty = new Set(['defs']);

function * cleaningOps(parentNode) {
    for (let child of Array.from(parentNode.childNodes)) {
        // Leave leading comments
        if (child.nodeType === Node.COMMENT_NODE && parentNode.nodeType !== Node.ELEMENT_NODE && parentNode.firstChild === child) {
            continue;
        }

        if (child.nodeType !== Node.ELEMENT_NODE) {
            yield () => child.remove();
            continue;
        }

        const el = child;

        for (const attrName of Array.from(el.attributes, attr => attr.name)) {
            if (doNotRemoveAttrs.has(attrName)) {
                continue;
            }
            yield () => el.removeAttribute(attrName);
        }

        for (const className of Array.from(el.classList)) {
            yield () => el.classList.remove(className);
        }

        for (const styleProp of Array.from(el.style)) {
            yield () => el.style.removeProperty(styleProp);
        }

        yield * cleaningOps(el);


        let keep = false;
        keep = keep || (parentNode.nodeType !== Node.ELEMENT_NODE);
        keep = keep || (keepIfNonEmpty.has(el.nodeName) && el.childNodes.length > 0);

        if (!keep) {
            yield () => el.replaceWith(...el.childNodes);
        }
    }
}

function * clopsEasy(parentNode) {
    // yield () => parentNode.documentElement.removeAttribute('fill');
    for (const circle of parentNode.querySelectorAll('circle')) {
        yield () => circle.remove();
    }
}

async function unjunk(svgCode, options) {
    options = { scale: 2, maxChannelDiff: 1, ...options };

    const snapshot = getImageData.bind(null, document.createElement('canvas').getContext('2d'), options.scale);
    let referenceData = snapshot(await createImage(svgCode));

    let skipOps = 0;
    for (let i = 0; i < 1000; i++) {
        // console.log('starting over');
        const doc = new DOMParser().parseFromString(svgCode, 'image/svg+xml');
        const opGenerator = cleaningOps(doc);
        // const opGenerator = clopsEasy(doc);

        for (let opNumber = 0; ; opNumber++) {
            const { done, value: op } = opGenerator.next();
            if (done) {
                return svgCode
            }
            if (opNumber < skipOps) {
                continue;
            }
            skipOps = opNumber + 1;
            // console.log(op);
            try {
                op();
                const newSvgCode = new XMLSerializer().serializeToString(doc);
                if (newSvgCode === svgCode) {
                    // console.log('Operation did nothing');
                    continue;
                }
                const pixData = snapshot(await createImage(newSvgCode));
                if (imageDataEquals(pixData, referenceData, options.maxChannelDiff)) {
                    // console.log('Operation successfull');
                    skipOps = opNumber;
                    svgCode = newSvgCode;
                    break;
                }
            } catch (e) {
                // console.error(e);
            }
            // console.log('Operation failed');
            break;
        }
    }

    console.log('Bailing out');

    return svgCode
}

</script>

    </body>
</html>